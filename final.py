# -*- coding: utf-8 -*-
"""Com_vis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jfHnsdbJ5HDNVPELIskqtmkE5nSVsQWT
"""

import cv2
import numpy



# A) CONVERTING THE RGB IMAGE TO GRAY SCALE IMAGE

def rgb_to_grayscale(pixel):
    R, G, B =pixel[0], pixel[1], pixel[2]
    return 0.2989 * R + 0.5870 * G + 0.1140 * B

def convertToGrayScale(img_array):
    img_width =len(img_array[0])
    img_height = len(img_array)
    out = numpy.empty([img_height, img_width])
    for i in range(0, img_height):
        for j in range(0, img_width):
            out[i][j] = rgb_to_grayscale(img_array[i][j])
    return out


# B) USING BILINEAR INTERPOLATION TO SCALE THE IMAGE
import math

def bilinearInterpolation(img, h, w):
  img_height = len(img)
  img_width = len(img[0])

  # resized = np.empty([height, width])

  resized_img = numpy.empty([h,w])

  x_ratio = float(img_width - 1) / (w - 1) if w > 1 else 0
  y_ratio = float(img_height - 1) / (h - 1) if h > 1 else 0

  for i in range(h):
    for j in range(w):


      x_l = math.floor(x_ratio * j) 
      y_l = math.floor(y_ratio * i)

      x_h = math.ceil(x_ratio * j)
      y_h = math.ceil(y_ratio * i)

      x_weight = (x_ratio * j) - x_l
      y_weight = (y_ratio * i) - y_l

      a = img[y_l, x_l]
      b = img[y_l, x_h]
      c = img[y_h, x_l]
      d = img[y_h, x_h]

      pixel = a * (1 - x_weight) * (1 - y_weight)  + b * x_weight * (1 - y_weight) +  c * y_weight * (1 - x_weight) +   d * x_weight * y_weight

      resized_img[i][j] = pixel
  return resized_img


# C) NORMALIZING THE IMAGE USING i_ = (i - mean)/(max i - min i) THEN SHIFT TO 0 - 1 SCALE THEN SCALE UP TO 0 - 255 PIXCEL RANGE
def normalizer(img):
  max = img.max()
  min = img.min()
  mean = img.mean()
  variation = max - min

  img_zero_mean = ( img - mean )/ variation * 1.0
  image_shift = img_zero_mean + img_zero_mean.max()
  image_shift_scale = image_shift / image_shift.max()

  image_grayscaled = image_shift_scale * 255
  return image_grayscaled


# D) NOICE FILTERS 
# LINEAR FILTER - MEAN FILTER IS USED
# NON-LINEAR FILTER - MEDIAN FILTER IS USED
# I used  3 x 3 kernal as the image seems as good quality and not much kernal size is needed to high smoothness and 3 x 3 is computationally less demand

def array_multiply(a,b):
    res = []
    for i in range(len(b[0])):
        sum = 0
        for j in range(len(a)):
            sum = sum + a[j] * b[j][i]
        res.append(sum)
    return res


def mean_filter(image):
    data_final = []
    data_final = numpy.zeros((len(image),len(image[0])))

    height, width = image.shape[0:2]
    mask = numpy.ones((3,3),numpy.float32)/9

    for i in range(2, height - 1):
        for j in range(2, width - 1):
            region = image[i - 1:i + 2, j - 1:j + 2]
            data_final[i][j] = sum(sum(array_multiply(region, mask))) / 3

    return data_final


def medianFilter(img):
    height,width = img.shape[0:2]
    mask = numpy.ones((3,3), numpy.float32)/9
    data_final = []
    data_final = numpy.zeros((len(img),len(img[0])))
    for i in range(2, height - 1):
        for j in range(2, width - 1):
            try:
                region = img[i-1: i+2, j-1: j+2]
                data_final[i][j] = numpy.median(region)
            except:
                pass
    return data_final


import scipy.misc
import scipy.stats as st
from math import atan,degrees

# E) CANNY EDGE DETECTION 
''' GAUSIAN SIGMA - 5 , LOWER THRESHOLD - 40, HIGHER THRESHOLD -  80
I HAVE CHOICE GAUSIAN SIGMA VALUE TO 5 AS OUT UNTIMATE GOAL IS TO FIND THE ROAD LANE . SO IF WE SMOOTH THE IMAGE MUCH AS ROAD LANE GAVE GOOD EDGES COMPARED TO OTHER EDGES IN ROAD IT WILL REDUCE THE
DEPTH OF THOSE UNWANTED EDGES SO OUTPUT IMAGE WILL SHOWS ROAD LANE AS WHOLE PERCENTAGE AND I CHOOSE LOWER THRESHOLD 40 SO THAT IT JOINS THE ROAD LANE PERFECTLY AND UPPER THRESHOLD ACCORDING TO THE NEED. I CHOOSE UPPER 
THRESHOLE TO 80 SO IT CHOSE THE HIGH DEPTH  EDGE ROAD LANES  DIRECTLY AS BEST LINE
 '''

K = 3
def gaussianKernal(size =21, sigma =30):
    interval = (2 * sigma + 1.) / (size)
    i = numpy.linspace(-sigma - interval / 2., sigma + interval / 2., size + 1)
    kernal1d = numpy.diff(st.norm.cdf(i))
    kernel2d = numpy.sqrt(numpy.outer(kernal1d, kernal1d))
    kernel = kernel2d/kernel2d.sum()
    return kernel

def GaussianCoefficients(sigma):
    return gaussianKernal(2 * K + 1, sigma)

def filterValue(kernel, pixel, k):
    total = 0
    for i in range(0, 2 * k + 1):
        for j in range(0, 2 * k + 1):
            total = total + kernel[i][j] * pixel[i][j]
    return total

def filter(kernel, img_array, k):
    img_width= len(img_array[0])
    img_height = len(img_array)
    filter_result = numpy.empty([img_height - 2 * k, img_width - 2 * k])
    for x in range(k, img_width -2 * k):
        for y in range(k, img_height -2 * k):
            filter_result[y][x] = filterValue(kernel, img_array[y - k : y + k + 1, x - k : x + k + 1], k)
    return filter_result

def magnitute_Degree(X, Y):
    width= len(X[0])
    height = len(X)
    magnitude = numpy.empty([height, width])
    degree = numpy.empty([height, width])
    for i in range(0, width):
        for j in range(0, height):
            magnitude[j][i] = numpy.math.sqrt(X[j][i] * X[j][i] + Y[j][i] * Y[j][i])
            degree[j][i] = atan(Y[j][i]/X[j][i])
    degree = (numpy.round(degree * (5.0 / numpy.pi)) + 5) % 5
    return magnitude, degree

def nonMaximaSupression(image,degree):
    width = len(image[0])
    height = len(image)
    for x in range(0,width):
      for y in range(0,height):
        if x == 0 or y == height -1 or y == 0 or x == width -1:
          image[y][x] = 0
          continue
        direction = degree[y][x] % 4
        if direction == 0:
            if image[y][x] <= image[y][x-1] or image[y][x] <= image[y][x+1]:
                image[y][x] = 0
        if direction == 1:
            if image[y][x] <= image[y-1][x+1] or image[y][x] <= image[y+1][x-1]:
                image[y][x] = 0
        if direction == 2:
            if image[y][x] <= image[y-1][x] or image[y][x] <= image[y+1][x]:
                image[y][x] = 0
        if direction == 3:
            if image[y][x] <= image[y-1][x-1] or image[y][x] <= image[y+1][x+1]:
                image[y][x] = 0
    return image



def doubleThreshold(image, lower_Threshold, higher_Threshold):
    image[numpy.where(image > higher_Threshold)] = 255
    image[numpy.where((image >= lower_Threshold) & (image <= higher_Threshold))] = 75
    image[numpy.where(image < lower_Threshold)] = 0
    return image

def trackEdge(image):
    width = len(image[0])
    height = len(image)
    for i in range(0, height):
        for j in range(0, width):
            if image[i][j] == 75:
                if ((image[i+1][j] == 255) or (image[i - 1][j] == 255) or (image[i][j + 1] == 255) or (image[i][j - 1] == 255) or (image[i+1][j + 1] == 255) or (image[i-1][j - 1] == 255)):
                    image[i][j] = 255
                else:
                    image[i][j] = 0
    return image

def cannyEdgeDetector(src, sigma, lowThreshold, highThreshold):
    output = src.copy()
    output = filter(GaussianCoefficients(sigma), output, K)
    output = output.astype(int)
    sx = filter(numpy.array([[1, 0, -1], [2, 0, -2], [1, 0, -1]]), output, 1)
    sy = filter(numpy.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]]), output, 1)
    gradientMagnitute, gradientdegree = magnitute_Degree(sx, sy)
    supressed = nonMaximaSupression(gradientMagnitute, gradientdegree)
    thresholded = doubleThreshold(supressed, lowThreshold, highThreshold)
    output = trackEdge(thresholded)
    return output


def main_170620P():
  img = cv2.imread('/dashcam_view_1.jpg')
  img_gray = convertToGrayScale(img)
  cv2.imwrite('image_gray.png', img_gray)
  
  new_width = int(img.shape[1] * 0.80)
  new_height = int (img.shape[0] * 0.8)
  img_scaled =bilinearInterpolation(img_gray, new_height, new_width)
  cv2.imwrite('image_scale.png', img_scaled)
  
  img_normalized = normalizer(img_scaled)
  cv2.imwrite('image_normalized.png', img_normalized)

  img_mean = mean_filter(img_normalized)
  cv2.imwrite('image_mean_filtered.png', img_mean)

  img_filter_median = medianFilter(img_mean)
  cv2.imwrite('image_median_filtered.png', img_filter_median)

  edgedetected_img = cannyEdgeDetector(img_filter_median, 5, 40, 80)
  cv2.imwrite('image_edgedetected_img.png', edgedetected_img)



main_170620P()

# h) Segmentation using Region Grow

class Point(object):
 def __init__(self,x,y):
  self.x = x
  self.y = y

 def getX(self):
  return self.x
 def getY(self):
  return self.y

def getGrayDifference(img,present_point,temperory_point):
 return abs(int(img[present_point.x,present_point.y]) - int(img[temperory_point.x,temperory_point.y]))

def selectingDots(p):
 if p != 0:
  connects = [Point(-1, -1), Point(0, -1), Point(1, -1), Point(1, 0), Point(1, 1), \
     Point(0, 1), Point(-1, 1), Point(-1, 0)]
 else:
  connects = [ Point(0, -1), Point(1, 0),Point(0, 1), Point(-1, 0)]
 return connects

def regionGrow(img,seeds,thresh,p = 1):
 height, weight = img.shape
 seedMark = numpy.zeros(img.shape)
 seedList = []
 for seed in seeds:
  seedList.append(seed)
 label = 255
 connects = selectingDots(p)
 while(len(seedList)>0):
  present_point = seedList.pop(0)

  seedMark[present_point.x,present_point.y] = label
  for i in range(8):
   tmpX = present_point.x + connects[i].x
   tmpY = present_point.y + connects[i].y
   if tmpX < 0 or tmpY < 0 or tmpX >= height or tmpY >= weight:
    continue
   grayDiff = getGrayDifference(img,present_point,Point(tmpX,tmpY))
   if grayDiff < thresh and seedMark[tmpX,tmpY] == 0:
    seedMark[tmpX,tmpY] = label
    seedList.append(Point(tmpX,tmpY))
 return seedMark

def rgb_to_grayscale(pixel):
    R, G, B =pixel[0], pixel[1], pixel[2]
    return 0.2989 * R + 0.5870 * G + 0.1140 * B

def convertToGrayScale(img_array):
    img_width =len(img_array[0])
    img_height = len(img_array)
    out = numpy.empty([img_height, img_width])
    for i in range(0, img_height):
        for j in range(0, img_width):
            out[i][j] = rgb_to_grayscale(img_array[i][j])
    return out

def medianFilter(img):
    height,width = img.shape[0:2]
    mask = numpy.ones((3,3), numpy.float32)/9
    data_final = []
    data_final = numpy.zeros((len(img),len(img[0])))
    for i in range(2, height - 1):
        for j in range(2, width - 1):
            try:
                region = img[i-1: i+2, j-1: j+2]
                data_final[i][j] = numpy.median(region)
            except:
                pass
    return data_final


img = cv2.imread('dashcam_view_1.jpg')
img_noice_filtered = medianFilter(convertToGrayScale(img))

# Road
seeds = [Point(700,870)]
binaryImg = regionGrow(img_noice_filtered,seeds,4)
# cv2_imshow(binaryImg)
cv2.imwrite('image_segmented_Road.png', binaryImg)

# Car 1
seeds = [Point(570,790), Point(530,840), Point(510,840), Point(486,840), Point(535,896), Point(542,823)]
binaryImg = regionGrow(img_noice_filtered,seeds,4)
# cv2_imshow(binaryImg)
cv2.imwrite('image_segmented_Car1_onRoad.png', binaryImg)

# Car 2
# seeds = [Point(900,850), Point(960,1300)]
binaryImg = regionGrow(img_noice_filtered,seeds,4)
# cv2_imshow(binaryImg)
cv2.imwrite('image_segmented_FrontCar.png', binaryImg)

# Sky
seeds = [Point(220,1160), Point(160,1300), Point(80,1500), Point(160,1820)]
binaryImg = regionGrow(img_noice_filtered,seeds,3)
# cv2_imshow(binaryImg)
cv2.imwrite('image_segmented_Sky.png', binaryImg)

# Others
seeds = [Point(350,160)]
binaryImg = regionGrow(img_noice_filtered,seeds,6)
# cv2_imshow(binaryImg)
cv2.imwrite('image_segmented_OthersSegments.png', binaryImg)